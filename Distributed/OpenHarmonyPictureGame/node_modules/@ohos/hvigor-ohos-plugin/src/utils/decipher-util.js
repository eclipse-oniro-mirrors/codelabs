"use strict";
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.
 *
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecipherUtil = void 0;
const crypto_1 = __importDefault(require("crypto"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const buffer_1 = __importDefault(require("buffer"));
const ohos_logger_js_1 = require("./log/ohos-logger.js");
/**
 * <p>密钥解码器</p>
 * <p>主要方法是#getKey()，用于读取工作密钥。</p>
 * <p>工作密钥采用AES-GCM方式进行解密，填充参数是NoPadding，密钥长度16 byte(128 bit)，iv长度12 byte(96bit)，iv每次都是采用SecureRandom生成，
 * tag参数长度128 bit。</p>
 * <p>根密钥由存储在文件中的组件以及硬编码在代码中的组件做异或操作得到一个组件，然后将该组件使用PBKDF2WithHmacSHA256迭代10000次生成</p>
 * <p>根据密钥管理规范，存储组件的文件名以及目录已采用一般化名称存储，未体现其是密钥等信息</p>
 * <p>主要参考文档《密钥管理安全规范 V1.3.docx》、《密码算法应用规范 V1.4.docx》、《对称加密算法应用方案.docx》</p>
 *
 * @since 2022/03/07
 */
class DecipherUtil {
    /**
     * 使用aes-gcm算法解密消息
     * AesGcmKit，其实现符合《密码算法应用规范 V1.4.docx》中针对于AES-GCM的使用要求
     * 填充参数是NoPadding，密钥长度16 byte(128 bit)，iv长度12 byte(96bit)，iv每次都是采用SecureRandom生成，tag参数长度16 byte(128 bit)。
     *
     * @param materialDir 签名材料地址
     * @param encryptedPwd 加密密码
     * @return string
     */
    static decryptPwd(materialDir, encryptedPwd) {
        if (32 > encryptedPwd.length) {
            this._logger._buildError('Illegal data, less than 32 characters.')
                ._solution('Please check the storePassword or keyPassword in build-profile.json5')
                ._file(path_1.default.resolve(process.cwd(), 'build-profile.json5'))
                ._printErrorAndExit();
        }
        let result = buffer_1.default.Buffer.from('');
        try {
            const key = DecipherUtil.getKey(materialDir);
            const msgBytes = new Int8Array(buffer_1.default.Buffer.from(encryptedPwd, 'hex'));
            result = DecipherUtil.decrypt(key, msgBytes);
        }
        catch (e) {
            this._logger
                ._buildError(e.message)
                ._solution('Signing failed. Please check the signing config.')
                ._file(path_1.default.resolve(process.cwd(), 'build-profile.json5'))
                ._callstack(e)
                ._printErrorAndExit();
        }
        return result.toString('utf-8');
    }
    /**
     * 获取解密密钥
     * @param materialDir 签名材料地址
     * @private Int8Array
     */
    static getKey(materialDir) {
        const material = path_1.default.resolve(materialDir, 'material');
        if (!fs_1.default.statSync(material).isDirectory()) {
            this._logger._buildError('No signing materials.')._printErrorAndExit();
        }
        const files = fs_1.default.readdirSync(material);
        if (0 === files.length) {
            this._logger._buildError('No signing materials.')._printErrorAndExit();
        }
        this.dirs.forEach(dirName => {
            if (!files.includes(dirName)) {
                this._logger._buildError(`Can not find signing material ${dirName}`)._printErrorAndExit();
            }
        });
        const components = this.readFd(path_1.default.resolve(material, this.dirs[0]));
        const salt = this.readSalt(path_1.default.resolve(material, this.dirs[1]));
        const rootKey = this.getRootKey(components, salt);
        const workMaterial = this.readWorkMaterial(path_1.default.resolve(material, this.dirs[2]));
        return new Int8Array(DecipherUtil.decrypt(rootKey, workMaterial));
    }
    /**
     * PBKDF2WithHmacSHA256迭代10000次生成rootKey
     * @param components
     * @param salt
     * @private
     */
    static getRootKey(components, salt) {
        const full = components.concat(this.component);
        const finalComponents = this.xorComponents(full);
        const buffer = crypto_1.default.pbkdf2Sync(finalComponents.toString(), salt, 10000, 16, 'sha256');
        return new Int8Array(buffer);
    }
    /**
     * 根据密钥解密, 获取明文密码
     * 被加密后的数据格式如下
     * 其中content数据中包含tag数据
     * -------------------------------------------------------------------------------
     * | content length (4byte) | iv key (12 byte) | encrypted | auth tag ( 16 byte ) |
     *  ------------------------------------------------------------------------------
     *
     * @param key 密钥
     * @param msg 加密密码
     * @private Buffer.Buffer
     */
    static decrypt(key, msg) {
        const len = ((msg[0] & 0xFF) << 24) | ((msg[1] & 0xFF) << 16) | ((msg[2] & 0xFF) << 8) | ((msg[3] & 0xFF));
        const ivLen = msg.length - 4 - len;
        const ivKey = msg.slice(4, 4 + ivLen);
        const decipherGCM = crypto_1.default.createDecipheriv('aes-128-gcm', key, ivKey);
        const authTag = msg.slice(msg.length - 16);
        decipherGCM.setAuthTag(authTag);
        const update = decipherGCM.update(msg.subarray(4 + ivLen, msg.length - 16));
        const final = decipherGCM.final();
        return buffer_1.default.Buffer.concat([update, final]);
    }
    static xorComponents(components) {
        components.forEach(value => {
            if (16 !== value.length) {
                this._logger._buildError('Signing material data error!')._printErrorAndExit();
            }
        });
        let result = this.xor(components[0], components[1]);
        for (let i = 2; i < components.length; i++) {
            result = this.xor(result, components[i]);
        }
        return buffer_1.default.Buffer.from(result);
    }
    /**
     * 异或
     * @param b1
     * @param b2
     * @private
     */
    static xor(b1, b2) {
        if (b1.byteLength !== b2.byteLength) {
            this._logger._buildError('Signing material data error!')._printErrorAndExit();
        }
        const result = new Int8Array(b1.byteLength);
        for (let i = 0; i < b1.byteLength; i++) {
            result[i] = b1[i] ^ b2[i];
        }
        return result;
    }
    /**
     * 读取./material/fd
     *
     * @param dir
     * @private
     */
    static readFd(dir) {
        if (!fs_1.default.existsSync(dir)) {
            this._logger._buildError('Material not found!')._printErrorAndExit();
        }
        const names = fs_1.default.readdirSync(dir);
        if (3 !== names.length) {
            this._logger._buildError('Signing material is illegal!')._printErrorAndExit();
        }
        const result = [];
        names.forEach(value => result.push(this.readDirBytes(path_1.default.resolve(dir, value))));
        return result;
    }
    /**
     * 读取盐值./material/ac
     * @param dir
     * @private
     */
    static readSalt(dir) {
        return this.readDirBytes(dir);
    }
    /**
     * workMaterial ./material/ce
     * @param dir
     * @private
     */
    static readWorkMaterial(dir) {
        return this.readDirBytes(dir);
    }
}
exports.DecipherUtil = DecipherUtil;
DecipherUtil.component = new Int8Array([0x31, 0xf3, 0x09, 0x73, 0xd6, 0xaf, 0x5b, 0xb8, 0xd3, 0xbe, 0xb1, 0x58, 0x65, 0x83, 0xc0, 0x77]);
DecipherUtil.dirs = ['fd', 'ac', 'ce'];
DecipherUtil._logger = ohos_logger_js_1.OhosLogger.getLogger('Decipher');
/**
 * 读取目录中文件 默认一个文件
 * @param dir
 * @private
 */
DecipherUtil.readDirBytes = (dir) => {
    if (!fs_1.default.existsSync(dir) || !fs_1.default.statSync(dir).isDirectory()) {
        DecipherUtil._logger._buildError('Can not find the signing material')._printErrorAndExit();
    }
    const names = fs_1.default.readdirSync(dir);
    if (1 !== names.length) {
        DecipherUtil._logger._buildError('Signing material error')._printErrorAndExit();
    }
    const buffer = fs_1.default.readFileSync(path_1.default.resolve(dir, names[0]));
    return new Int8Array(buffer);
};
//# sourceMappingURL=decipher-util.js.map