"use strict";
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Clean = void 0;
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const module_task_service_js_1 = require("../service/module-task-service.js");
const hvigor_base_1 = require("@ohos/hvigor-base");
const ohos_logger_js_1 = require("../../utils/log/ohos-logger.js");
const pretty_hrtime_1 = __importDefault(require("pretty-hrtime"));
/**
 * module级别的clean
 *
 * @since 2022/1/10
 */
class Clean extends hvigor_base_1.Task {
    constructor(taskService) {
        super();
        this._logger = ohos_logger_js_1.OhosLogger.getLogger(Clean.name);
        this.registry = () => {
            return this.clean;
        };
        this.clean = (cb) => {
            let buildDir;
            const taskBeginTime = process.hrtime();
            let moduleName;
            if (this._taskService instanceof module_task_service_js_1.ModuleTaskService) {
                const moduleModel = this._taskService.getModuleModel();
                moduleName = moduleModel.getName();
                if (!moduleModel) {
                    return;
                }
                buildDir = path_1.default.resolve(moduleModel.getProjectDir(), "build");
            }
            else {
                moduleName = this._taskService.getProjectModel().getName();
                buildDir = path_1.default.resolve(this._taskService.getProjectModel().getProjectDir(), "build");
            }
            let hasError = false;
            if (fs.existsSync(buildDir)) {
                hasError = this.rmdirSync(buildDir, false);
            }
            const taskEndTime = process.hrtime(taskBeginTime);
            const realTime = (0, pretty_hrtime_1.default)(taskEndTime);
            this._logger._printTaskInfo(moduleName, "Clean", realTime);
            cb();
            if (hasError) {
                process.exit(-1);
            }
        };
        this.rmdirSync = (dirPath, hasError) => {
            fs.readdirSync(dirPath).forEach(name => {
                const filePath = path_1.default.resolve(dirPath, name);
                const fileStats = fs.statSync(filePath);
                if (fileStats.isFile()) {
                    try {
                        fs.unlinkSync(filePath);
                    }
                    catch (e) {
                        this._logger.warn(e.message);
                        hasError = true;
                    }
                }
                else if (fileStats.isDirectory()) {
                    hasError = this.rmdirSync(filePath, hasError);
                }
            });
            try {
                let canRm = true;
                const files = fs.readdirSync(dirPath);
                files.forEach(name => {
                    const filePath = path_1.default.resolve(dirPath, name);
                    if (fs.existsSync(filePath)) {
                        canRm = false;
                    }
                });
                if (canRm) {
                    fs.rmdirSync(dirPath);
                }
            }
            catch (e) {
                this._logger.warn(e.message);
                hasError = true;
            }
            return hasError;
        };
        this._taskService = taskService;
    }
}
exports.Clean = Clean;
//# sourceMappingURL=clean.js.map