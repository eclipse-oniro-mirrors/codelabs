"use strict";
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessLibs = void 0;
const glob_1 = require("glob");
const os_1 = __importDefault(require("os"));
const ohos_hap_task_js_1 = require("./task/ohos-hap-task.js");
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const fs = __importStar(require("fs-extra"));
const build_directory_const_js_1 = require("../const/build-directory-const.js");
const ohos_logger_js_1 = require("../utils/log/ohos-logger.js");
const project_file_reader_js_1 = require("../utils/project-file-reader.js");
/**
 * 收集hap和har依赖中的.so文件
 *
 * @since 2022/1/20
 */
class ProcessLibs extends ohos_hap_task_js_1.OhosHapTask {
    constructor(taskService) {
        super(taskService, "ProcessLibs");
        this._log = ohos_logger_js_1.OhosLogger.getLogger(ProcessLibs.name);
        this._moduleModel = taskService.getModuleModel();
        this._moduleDir = this._moduleModel.getProjectDir();
    }
    doTaskAction(targetData, target) {
        const pathInfo = targetData.getPathInfo();
        // hap native构建产物
        const hapBuildLibs = path_1.default.resolve(pathInfo.getIntermediatesCppOutPut());
        // hap本地native依赖
        const hapLocalLibs = path_1.default.resolve(this._moduleDir, build_directory_const_js_1.BuildDirConst.LIBS);
        // har携带native依赖
        const harList = project_file_reader_js_1.ProjectFileReader.getJson5Obj(path_1.default.resolve(pathInfo.getIntermediatesMergeRes(), build_directory_const_js_1.BuildArtifactConst.MERGE_NPM_FILE_JSON)).dependencies;
        const localModuleList = project_file_reader_js_1.ProjectFileReader.getJson5Obj(path_1.default.resolve(pathInfo.getIntermediatesMergeRes(), build_directory_const_js_1.BuildArtifactConst.MERGE_NPM_FILE_JSON)).local.path;
        const harLibs = [...(0, lodash_1.difference)(harList, localModuleList).map(harPath => {
                return path_1.default.resolve(harPath, build_directory_const_js_1.BuildDirConst.LIBS);
            }), ...localModuleList.map(harPath => {
                return path_1.default.resolve(harPath, build_directory_const_js_1.BuildDirConst.BUILD_ROOT, "default", build_directory_const_js_1.BuildDirConst.INTERMEDIATES, build_directory_const_js_1.BuildDirConst.LIBS, "default");
            })];
        const libsCollections = [...harLibs, hapBuildLibs, hapLocalLibs];
        this._log.debug(`Libs: ${libsCollections.join(os_1.default.EOL)}`);
        // output路径
        const libsOutputDir = pathInfo.getIntermediatesProcessLibs();
        fs.emptyDirSync(libsOutputDir);
        // 先收集所有的目标.so文件，存进set内
        const fullSet = {};
        libsCollections.forEach(libsPath => {
            const paths = glob_1.glob.sync("**/*.so", {
                cwd: libsPath
            });
            this._log.debug(`Collect files: ${paths}`);
            paths.forEach(soPath => {
                if (!fullSet[soPath]) {
                    fullSet[soPath] = [];
                }
                fullSet[soPath].push(path_1.default.resolve(libsPath, soPath));
            });
        });
        let flag = false;
        const errorLog = [];
        for (const key in fullSet) {
            const fileName = path_1.default.basename(key);
            const len = fullSet[key].length;
            if (len > 1 && !(fileName === "libc++.so" || fileName === "libc++_shared.so")) {
                flag = true;
                errorLog.push(`${len} files found for path 'lib/${key}'. This can cause unexpected errors at runtime.`);
                fullSet[key].forEach(value => {
                    errorLog.push(`- ${value}`);
                });
            }
        }
        if (flag) {
            this._log._buildError(errorLog.join(`${os_1.default.EOL}\t `))
                ._solution("Try to rename native compilation products of modules.")
                ._printErrorAndExit(this.moduleName);
        }
        // 复制libs内文件到打包路径
        libsCollections.forEach(libsPath => {
            if (fs.pathExistsSync(libsPath)) {
                fs.copySync(libsPath, libsOutputDir);
            }
        });
    }
}
exports.ProcessLibs = ProcessLibs;
//# sourceMappingURL=process-libs.js.map