"use strict";
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2021-2022. All rights reserved.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegacyMergeProfile = void 0;
const fs = __importStar(require("fs-extra"));
const ohos_hap_task_js_1 = require("../task/ohos-hap-task.js");
const path_1 = __importDefault(require("path"));
const common_const_js_1 = require("../../const/common-const.js");
const lodash_1 = require("lodash");
const hvigor_base_1 = require("@ohos/hvigor-base");
const build_directory_const_js_1 = require("../../const/build-directory-const.js");
const merge_type_rule_js_1 = require("../../enum/merge-type-rule.js");
const ohos_logger_js_1 = require("../../utils/log/ohos-logger.js");
const project_file_reader_js_1 = require("../../utils/project-file-reader.js");
/**
 * 合并config.json
 *
 * @since 2022/1/19
 */
class LegacyMergeProfile extends ohos_hap_task_js_1.OhosHapTask {
    constructor(taskService) {
        super(taskService, "LegacyMergeProfile");
        this._log = ohos_logger_js_1.OhosLogger.getLogger(LegacyMergeProfile.name);
    }
    mergeDslConfig(configOpt) {
        var _a, _b, _c;
        // 从product处获取bundleName
        const bundleName = (_a = this._moduleTargetData) === null || _a === void 0 ? void 0 : _a.getProduct().bundleName;
        const targetSdkVersion = (_b = this.service.getProjectModel()) === null || _b === void 0 ? void 0 : _b.getCompileApiVersion();
        const compatibleSdkVersion = (_c = this.service.getProjectModel()) === null || _c === void 0 ? void 0 : _c.getCompatibleApiVersion();
        const releaseType = this.service.getSdkInfo().getReleaseType();
        if (bundleName) {
            configOpt.app.bundleName = bundleName;
            this._appBundleName = bundleName;
            this._log.debug(`Change app bundleName with '${bundleName}'.`);
        }
        this._log.debug(`Change app target API version with '${targetSdkVersion}'`);
        this._log.debug(`Change app minimum API version with '${compatibleSdkVersion}'`);
        this._log.debug(`Change app releaseType with '${releaseType}'`);
        configOpt.app.apiVersion = {
            target: targetSdkVersion,
            compatible: compatibleSdkVersion,
            releaseType: releaseType
        };
    }
    doTaskAction(moduleTargetData, target) {
        var _a;
        this._moduleTargetData = moduleTargetData;
        const targetSourceSetModel = this.service.getModuleModel()
            .getSourceSetByTargetName(target);
        const configOpt = targetSourceSetModel.getLegacyModuleTargetRes().getConfigJsonOpt();
        this._appBundleName = (_a = configOpt.app) === null || _a === void 0 ? void 0 : _a.bundleName;
        const deviceType = configOpt.module.deviceType;
        if (this.service.getModuleModel().isHarModule() && deviceType.length === 0) {
            const cause = "The value of 'deviceType' in the config.json is empty.";
            const solution = "Please check the deviceType field in the config.json file is correctly configured.";
            this._log._buildError(cause)
                ._solution(solution)
                ._file(targetSourceSetModel.getLegacyModuleTargetRes().getJsonPath())
                ._printErrorAndExit();
        }
        // 三方依赖的config.json
        const mergedNpmResFile = path_1.default.resolve(moduleTargetData.getPathInfo().getIntermediatesMergeRes(), build_directory_const_js_1.BuildArtifactConst.MERGE_NPM_FILE_JSON);
        const harList = fs.readJsonSync(mergedNpmResFile, { throws: false }).dependencies;
        const localModuleList = fs.readJsonSync(mergedNpmResFile, { throws: false }).local.path;
        const harLibs = [...(0, lodash_1.difference)(harList, localModuleList).map(harPath => {
                return path_1.default.resolve(harPath, "src", "main", common_const_js_1.CommonConst.CONFIG_JSON);
            }), ...localModuleList.map(harPath => {
                return path_1.default.resolve(harPath, build_directory_const_js_1.BuildDirConst.BUILD_ROOT, "default", build_directory_const_js_1.BuildDirConst.INTERMEDIATES, build_directory_const_js_1.BuildDirConst.INTERMEDIATES_MERGE_PROFILE, "default", common_const_js_1.CommonConst.CONFIG_JSON);
            })];
        const harConfigOpts = harLibs.map(harConfigJson => {
            if (fs.pathExistsSync(harConfigJson)) {
                return project_file_reader_js_1.ProjectFileReader.getJson5Obj(harConfigJson);
            }
            else {
                this._log.warn(`${harConfigJson} does not exist. This library will not be 
                merged. Please confirm the correctness of this module.`);
            }
        });
        // 合并hapConfig和所有harConfig
        const mergedConfigOpt = this.mergeAllConfig(configOpt, harConfigOpts);
        // 用项目配置覆盖模块的bundleName和api版本信息
        this.mergeDslConfig(mergedConfigOpt);
        // debug模式添加debug: true
        const debuggable = hvigor_base_1.vigorConfigInst.getExtraConfig().get(common_const_js_1.CommonConst.DEBUGGABLE);
        if (debuggable === undefined || debuggable) {
            const deviceConfigObj = mergedConfigOpt.deviceConfig;
            if (deviceConfigObj.default === undefined) {
                mergedConfigOpt.deviceConfig.default = {};
            }
            mergedConfigOpt.deviceConfig.default.debug = true;
        }
        // 将merged json写入文件
        const pathInfo = moduleTargetData.getPathInfo();
        const mergedModuleJson = pathInfo.getIntermediatesMergeLegacyProfile();
        fs.outputJSONSync(mergedModuleJson, mergedConfigOpt, { spaces: "\t" });
    }
    mergeAllConfig(mainConfig, harConfigOpts) {
        var _a, _b;
        for (const harModuleOpt of harConfigOpts) {
            // api版本兼容，hap的compatible要大于等于三方包的compatible
            if (((_a = harModuleOpt.app.apiVersion) === null || _a === void 0 ? void 0 : _a.compatible) > ((_b = mainConfig.app.apiVersion) === null || _b === void 0 ? void 0 : _b.compatible)) {
                this._log._buildError(`The compatible version of har module 
                ${harModuleOpt.module.name} is lower than hap module.`)
                    ._printErrorAndExit(this.moduleModel.getName());
            }
            mainConfig = this.mergeModel(mainConfig, harModuleOpt, "config");
        }
        return mainConfig;
    }
    /**
     * 合并对象
     *
     * @param mainModel 主模型对象
     * @param subModel 副模型对象
     * @param {string} clazz 当前合并对象的标签字段
     * @returns {any} 合并后的模型
     * @private
     */
    mergeModel(mainModel, subModel, clazz) {
        if (Object.values(merge_type_rule_js_1.KeepHapOptions).includes(clazz)) {
            return mainModel;
        }
        if (!mainModel) {
            return subModel;
        }
        if (!subModel) {
            return mainModel;
        }
        const keys = (0, lodash_1.union)(Object.keys(mainModel), Object.keys(subModel));
        keys.forEach(key => {
            const mainValue = mainModel[key];
            const subValue = subModel[key];
            let realValue;
            if (mainValue && subValue && typeof mainValue !== typeof subValue) {
                this._log._buildError(`Type of attribute ${key} in config.json/module.json5 of har
                 is different from the one in hap. Please check the correctness of config.json/module.json5.`)
                    ._printErrorAndExit(this.moduleModel.getName());
            }
            this.checkFieldRule(mainModel, subModel, key, clazz);
            const curType = mainValue === undefined ? typeof subValue : typeof mainValue;
            switch (curType) {
                // 布尔类型的字段，除了har存在而hap不存在的场景，用hap覆盖har配置
                case "boolean":
                    if (Object.values(merge_type_rule_js_1.KeepOneOfThem).includes(key)) {
                        realValue = mainValue === undefined && subValue !== undefined ? subValue : mainValue;
                        mainModel[key] = realValue;
                    }
                    break;
                /*
                 * 字符串和整数类型的字段，如果是module或者deviceConfig字段中的内容，即便hap没有配置，也使用hapValue；
                 * 否则har存在而hap不存在的场景，用hap覆盖har配置
                 */
                case "string":
                case "number":
                    realValue = mainValue === undefined && subValue !== undefined ? subValue : mainValue;
                    if (clazz === "deviceConfig" || clazz === "module") {
                        realValue = mainValue;
                    }
                    break;
                case "object":
                    if (Array.isArray(mainValue) || Array.isArray(subValue)) {
                        const mainList = Array.isArray(mainValue) ? mainValue : [];
                        const subList = Array.isArray(subValue) ? subValue : [];
                        let curFieldList = [];
                        if (clazz === "module" && Object.values(merge_type_rule_js_1.KeepModuleAttr).includes(key)) {
                            curFieldList = [...mainList];
                        }
                        else {
                            curFieldList = this.mergeList(mainList, subList, key);
                        }
                        if (curFieldList.length !== 0) {
                            mainModel[key] = curFieldList;
                        }
                    }
                    else if (Object.values(merge_type_rule_js_1.IsMapFields).includes(key)) {
                        let flag = true;
                        let curFieldMap = {};
                        if (clazz === "config") {
                            flag = false;
                            if (mainValue["default"] === undefined && subValue["default"] !== undefined) {
                                if (subValue["default"]["allowComponentsProxy"] === undefined) {
                                    subValue["default"] = undefined;
                                }
                                else {
                                    mainValue["default"] = {};
                                }
                            }
                        }
                        curFieldMap = this.mergeMap(mainValue, subValue, flag, key);
                        mainModel[key] = curFieldMap;
                    }
                    else {
                        mainModel[key] = this.mergeModel(mainValue, subValue, key);
                    }
                    break;
                default:
                    this._log.error("An unrecognized type!");
                    break;
            }
        });
        return mainModel;
    }
    mergeList(mainValue, subValue, field) {
        let mergedList = [];
        if (field === "skills") {
            return mainValue;
        }
        const curType = mainValue.length === 0 ? typeof subValue[0] : typeof mainValue[0];
        switch (curType) {
            case "string":
                mergedList = (0, lodash_1.union)(mainValue, subValue);
                break;
            case "object":
                if (Object.values(merge_type_rule_js_1.HasPlaceholderOptions).includes(field)) {
                    mainValue.forEach(value => {
                        this.disposePlaceHolder(value, field);
                    });
                    subValue.forEach(value => {
                        this.disposePlaceHolder(value, field);
                    });
                }
                mainValue.forEach(mainElement => {
                    const subElement = this.findObjectByUniqueKey(subValue, mainElement, field);
                    if (subElement === null) {
                        mergedList.push(mainElement);
                    }
                });
                subValue.forEach(subElement => {
                    const mainElement = this.findObjectByUniqueKey(mainValue, subElement, field);
                    if (mainElement === null) {
                        mergedList.push(subElement);
                    }
                    else {
                        const mergeElement = this.mergeModel(mainElement, subElement, field);
                        mergedList.push(this.mergeRule(mergeElement, mainElement));
                    }
                });
                break;
            default:
                this._log.error(`Other Type! ${field}`);
        }
        for (const value of mergedList) {
            if (Object.keys(value).includes("mergeRule")) {
                value["mergeRule"] = undefined;
            }
        }
        return mergedList;
    }
    findObjectByUniqueKey(list, model, field) {
        const uniqueKey = this.getUniqueKey(model, field);
        for (const subModel of list) {
            const compareKey = this.getUniqueKey(subModel, field);
            if (field === "abilities") {
                const mainTargetAbilityName = model["targetAbility"];
                const subTargetAbilityName = subModel["targetAbility"];
                if (mainTargetAbilityName !== undefined &&
                    subTargetAbilityName === undefined &&
                    mainTargetAbilityName === uniqueKey) {
                    this._log._buildError(`The target function was incorrectly configured. '${mainTargetAbilityName}' 
                    conflict occurred when merging the config.json files in HAP and HAR packages.`)
                        ._printErrorAndExit(this.moduleModel.getName());
                }
            }
            if (uniqueKey === compareKey) {
                return subModel;
            }
        }
        return null;
    }
    getUniqueKey(model, clazz) {
        if (Object.values(merge_type_rule_js_1.UniqueKeyEqualsName).includes(clazz)) {
            return model["name"];
        }
        else if (clazz === "shortcuts") {
            return model["shortcutId"];
        }
        else if (clazz === "abilities") {
            if (model["targetAbility"] === undefined) {
                return model["name"];
            }
            else {
                return model["targetAbility"];
            }
        }
        else {
            return null;
        }
    }
    mergeRule(mergeValue, mainValue) {
        if (mainValue === null || mainValue.mergeRule === undefined) {
            return mergeValue;
        }
        const mergeRule = mainValue.mergeRule;
        if (mergeRule.replace) {
            const replaceLabel = mergeRule.replace;
            replaceLabel.forEach(fieldItem => {
                if (mergeValue[fieldItem]) {
                    mergeValue[fieldItem] = mainValue[fieldItem];
                }
            });
        }
        if (mergeRule.remove) {
            const removeLabel = mergeRule.remove;
            removeLabel.forEach(fieldItem => {
                if (mergeValue[fieldItem]) {
                    mergeValue[fieldItem] = undefined;
                }
            });
        }
        return mergeValue;
    }
    mergeMap(mainValue, subValue, flag, key) {
        if (mainValue === undefined) {
            return mainValue;
        }
        if (subValue === undefined) {
            return subValue;
        }
        const mergedMap = (0, lodash_1.cloneDeep)(mainValue);
        const mainKeys = Object.keys(mainValue);
        const subKeys = Object.keys(subValue);
        const addKeys = (0, lodash_1.difference)(subKeys, mainKeys);
        if (flag) {
            addKeys.forEach(addKey => {
                mergedMap[addKey] = subValue[addKey];
            });
        }
        const sameKeys = (0, lodash_1.intersection)(subKeys, mainKeys);
        sameKeys.forEach(sameKey => {
            if (mainValue[sameKey] instanceof Array) {
                mergedMap[sameKey] = (0, lodash_1.union)(mainValue[sameKey], subValue[sameKey]);
            }
            else if (typeof mainValue[sameKey] === "object") {
                mergedMap[sameKey] = this.mergeModel(mainValue[sameKey], subValue[sameKey], key);
            }
        });
        return mergedMap;
    }
    checkFieldRule(mainModel, subModel, key, clazz) {
        if (!Object.values(merge_type_rule_js_1.IsNeedMergeRule).includes(clazz)
            || Object.values(merge_type_rule_js_1.KeepAbilityMergeList).includes(clazz)
            || key === "skills") {
            return;
        }
        const mainValue = mainModel[key];
        const subValue = subModel[key];
        if (mainValue === undefined || subValue === undefined) {
            return;
        }
        if (!(0, lodash_1.isEqual)(mainValue, subValue)) {
            const mergeRule = mainModel["mergeRule"];
            const mergeRuleList = (0, lodash_1.union)(mergeRule["replace"], mergeRule["remove"]);
            if (!mergeRuleList.includes(key)) {
                const uniqueKey = this.getUniqueKey(mainValue, clazz);
                const err = `Unable to merge Config.json files. 
                    The value '${clazz}'${uniqueKey}' conflicts with 
                    the value ':${key}' of a subtag in the HAR file. 
                    Please verify and then add 'mergeRule' in the HAP.`;
                this._log._buildError(err)
                    ._printErrorAndExit(this.moduleModel.getName());
                throw new Error(err);
            }
        }
    }
    disposePlaceHolder(config, clazz) {
        const keys = Object.keys(config);
        keys.forEach(key => {
            if (Object.values(merge_type_rule_js_1.NeedDisposePlaceholder).includes(key)
                && !(clazz === "abilities" && key === "name")) {
                const keyObj = config[key];
                if (typeof keyObj === "string") {
                    config[key] = keyObj.replace("{bundleName}", this._appBundleName);
                }
                else if (keyObj instanceof Array && keyObj.length !== 0) {
                    if (typeof keyObj[0] === "string") {
                        const newArray = [];
                        for (const value of config[key]) {
                            newArray.push(value.replace("{bundleName}", this._appBundleName));
                        }
                        config[key] = newArray;
                    }
                    else {
                        const newArray = [];
                        for (const value of config[key]) {
                            newArray.push(value.name.replace("{bundleName}", this._appBundleName));
                        }
                        config[key] = newArray;
                    }
                }
            }
        });
        return config;
    }
}
exports.LegacyMergeProfile = LegacyMergeProfile;
//# sourceMappingURL=legacy-merge-profile.js.map