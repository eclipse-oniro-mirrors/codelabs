"use strict";
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
 *
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildNative = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const native_command_builder_js_1 = require("../builder/native-command-builder.js");
const process_utils_js_1 = require("../utils/process-utils.js");
const ohos_hap_task_js_1 = require("./task/ohos-hap-task.js");
const code_type_enum_js_1 = require("../enum/code-type-enum.js");
const cpu_abi_enum_js_1 = require("../enum/cpu-abi-enum.js");
const ohos_logger_js_1 = require("../utils/log/ohos-logger.js");
/**
 * ohos native代码编译so任务
 *
 * @since 2021/1/21
 */
class BuildNative extends ohos_hap_task_js_1.OhosHapTask {
    constructor(taskService) {
        super(taskService, "BuildNative");
        this._log = ohos_logger_js_1.OhosLogger.getLogger(BuildNative.name);
        this._moduleModel = taskService.getModuleModel();
        const profileOption = this._moduleModel.getProfileOpt();
        this._nativeOption = profileOption.buildOption.externalNativeOptions;
        this._sdkInfo = this.service.getSdkInfo();
    }
    buildCommand(abiFilter, target) {
        const builder = new native_command_builder_js_1.NativeCommandBuilder(this._ninjaPath)
            .changeToDir(path_1.default.resolve(this._moduleModel.getProjectDir(), '.cxx', 'default', 'default', abiFilter));
        const commands = builder.build();
        this._log._printDebugCommand("Cmake", commands);
        new process_utils_js_1.ProcessUtils(this.moduleName, this.taskName).executeSync(commands);
    }
    doTaskAction(targetData, target) {
        const moduleModel = this.service.getModuleModel();
        const codeMap = moduleModel.getSourceSetByTargetName().getCodeMap();
        const pathInfo = targetData.getPathInfo();
        const outputDir = path_1.default.resolve(pathInfo.getModuleBuildIntermediates(), 'cmake', target, 'obj');
        if (fs_extra_1.default.existsSync(outputDir)) {
            fs_extra_1.default.emptyDirSync(outputDir);
        }
        if (!codeMap.has(code_type_enum_js_1.CodeType.CPP) || !this._nativeOption) {
            return;
        }
        this._ninjaPath = this._sdkInfo.getNativeNinjaTool();
        const profileOption = this._moduleModel.getProfileOpt();
        const abiFilters = profileOption.buildOption.externalNativeOptions.abiFilters;
        if (!abiFilters || 0 === abiFilters.length) {
            return;
        }
        abiFilters.forEach(abiFilter => {
            this.buildCommand(abiFilter, target);
            // TODO 暂时方案, 确定目录结构后修改
            const outputFilterDir = path_1.default.resolve(outputDir, abiFilter);
            this.copyLibSo(abiFilter, outputFilterDir, pathInfo);
        });
    }
    /**
     * 临时拷贝libc++.so
     *
     * 设置了 -DOHOS_STL=c++_static 或者 -DOHOS_STL=none 时，不拷贝 libc++.so，且删除临时目录下的libc++.so
     * 设置了 –DOHOS_STL=c++_shared时 拷贝llvm/lib/{arch}-linux-ohos/c++/libc++_shared.so 到临时目录
     * 最终打包到hap的lib目录下
     *
     * @param abiFilter abiFilter
     * @param outputDir 临时目录
     * @param pathInfo pathInfo
     * @private copyLibSo
     */
    copyLibSo(abiFilter, outputDir, pathInfo) {
        const args = this.getArguments();
        const delCpp = args.some(value => '-DOHOS_STL=c++_static' === value) ||
            args.some(value => '-DOHOS_STL=none' === value);
        const libSo = path_1.default.resolve(outputDir, 'libc++.so');
        const sharedSo = path_1.default.resolve(outputDir, 'libc++_shared.so');
        const libsSo = path_1.default.resolve(pathInfo.getModuleBuildIntermediates(), 'libs', abiFilter);
        if (delCpp) {
            fs_extra_1.default.removeSync(libSo);
            fs_extra_1.default.removeSync(sharedSo);
            fs_extra_1.default.removeSync(libsSo);
            return;
        }
        const soLibPath = path_1.default.resolve(this._sdkInfo.getSdkNativeDir(), 'llvm', 'lib', cpu_abi_enum_js_1.CpuAbiEnum.getCpuType(abiFilter), 'c++');
        const cppLibSo = path_1.default.resolve(soLibPath, 'libc++.so');
        const sharedLibSo = path_1.default.resolve(soLibPath, 'libc++_shared.so');
        if (args.some(value => '-DOHOS_STL=c++_shared' === value) && fs_extra_1.default.existsSync(sharedLibSo)) {
            fs_extra_1.default.copySync(sharedLibSo, sharedSo);
        }
        if (fs_extra_1.default.existsSync(cppLibSo)) {
            fs_extra_1.default.copySync(cppLibSo, libSo);
        }
    }
    getArguments() {
        const argument = this._nativeOption.arguments;
        if (argument && '' !== argument) {
            return argument.split(' ');
        }
        return [];
    }
}
exports.BuildNative = BuildNative;
//# sourceMappingURL=build-native.js.map